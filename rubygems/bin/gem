#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'rubygems'
require 'yaml'
require 'pp'


#
# -_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
#


def _info(message)
  STDOUT.puts message
end


def _die(message)
  STDERR.puts message
  exit!
end


#
# -_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
#


#
# This class defines the options structure used to capture the command-line options and
# drive the operational aspect.
#
class RubyGemsOptions
  
  def initialize
    @directory = Gem.dir  # TODO: should this be done here?
    @domain    = :both
  end

  # --- Operations ---
  
  # The operation the user has asked us to perform.
  attr_accessor :operation
  VALID_OPERATIONS = [:install, :uninstall, :list, :search, :info, :build, :alien, :verify]

  # Most operations require an argument (e.g. gemfile, pattern).
  attr_accessor :argument

  # --- Modifiers ---

  attr_accessor :config_file, :directory, :force, :gen_rdoc, :run_tests, :http_proxy, :gem_version

  # Specifies whether we are working in the :local or :remote domain (or +nil+ for
  # both/neither).
  attr_accessor :domain
  VALID_DOMAINS = [:local, :remote, :both]

  # --- Other attributes (not taken from command-line yet) ---
  
  attr_accessor :rdoc_args

  # --- Methods ---

  # Tells us whether this object is sensibly constructed.  Checks for valid operation and
  # domain values.
  def valid?
    VALID_OPERATIONS.include? operation and
      VALID_DOMAINS.include? domain
  end

  # Are local operations permitted?
  def local?
    domain == :both or domain == :local
  end

  # Are remote operations permitted?
  def remote?
    domain == :both or domain == :remote
  end

  def [](attr)
    self.send(attr)
  end

  def []=(attr, value)
    self.send("#{attr}=", value)
  end

end  # class RubyGemsOptions


#
# -_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
#


#
# This class handles the mechanics of interpreting command-line arguments and deciding
# what to do.
#
class RubyGemsApp
  #
  # Determine the selected operation and the other options, and ask RubyGemsFacade to do
  # the work for us.
  #
  def run(args)
    options = _determine_options(args)
    facade = RubyGemsFacade.new(options)
    arg = options.argument
    case options.operation
    when :install
      facade.install(arg)
    when :uninstall
      facade.uninstall(arg)
    when :list
      facade.list(arg)
    when :search
      facade.search(arg)
    when :info
      facade.info(arg)
    when :build
      facade.build(arg)
    when :alien
      facade.alien()
    when :verify
      facade.verify(arg)
    else
      _die "Invalid operation: #{options.operation}"
    end
  end

  private

  #
  # From the given argument array +args+, we return a RubyGemsOptions
  # object.  The parsing is done in <tt>_parse_options</tt>, but this
  # method also takes account of the configuration file, if there is
  # one.
  #
  def _determine_options(args)
    args = args.dup       # So we can manipulate it.
    options = RubyGemsOptions.new

    config = _get_config_data(args)
    if config
      if gem_opts = config['gem']
        # Prepend the 'gem' arguments to our current command line so they'll be read first.
        # REMOVE THIS args.unshift(gem_opts.split).flatten!
        args = gem_opts.split + args
      end
      options.rdoc_args = config['rdoc']
      if gempath = config['gempath']
        gempath = [gempath] unless gempath.is_a? Array
        # TODO: Set GEMPATH now -- how?
        options.directory = gempath[0]
      end
    end

    options = _parse_options(args, options)
  end

  #
  # Returns a hash of the config file data, taking the following into
  # account:
  #  - a config file may be specified on the command line
  #  - if it's specified multiple times, the last one wins 
  #  - there is a default config file location
  #
  # TODO: improve exception handling 
  #
  def _get_config_data(args)
    config_file = File.join(ENV['HOME'], ".gemrc")
    specified = false
    args.each_with_index do |arg, i|
      if arg == '--config-file'
        config_file = args[i+1]
        specified = true
      end
    end
    if File.exist?(config_file)
      return YAML.load(File.read(config_file))
    else
      _die "Config file #{config_file} not found" if specified
    end
  rescue YAML::Error # XXX: Is this the correct error?
    _die "Config file #{config_file} is not valid YAML"
  end
  
  #
  # Parse the arguments given and return a RubyGemsOptions object.
  #
  def _parse_options(args, options=nil)
    options ||= RubyGemsOptions.new
    o = options
    parser = OptionParser.new do |op|
      op.banner = <<BANNER
    
Usage: gem <action> [modifier ...]
BANNER
  
      op.separator("")
      op.separator("Operations:")
  
      op.separator("")
      op.separator("  Install/Uninstall:")
  
      op.on('-i', '--install GEM', "Install a gem from a local file or remote server") { |gem|
        o.operation = :install
        o.argument  = gem
      }
      op.on('-u', '--uninstall GEM', "Uninstall a previously installed gem") { |gem|
        o.operation = :uninstall
        o.argument  = gem
      }
  
      op.separator("")
      op.separator("  List/Search/Info:")
  
      op.on('-l', '--list [STR]', "List all local and/or remote gems (beginning with STR)") { |str|
        o.operation = :list
        o.argument  = str
      }
      op.on('-s', '--search STR', "List local and/or remote gems containing STR") { |str|
        o.operation = :search
        o.argument  = str || ""   
      }
      op.on('-o', '--info GEM', "Display information about local/remote gem named GEM") { |gem|
        o.operation = :info
        o.argument  = gem
      }
  
      op.separator("")
      op.separator("  Build:")
  
      op.on('-b', '--build GEMSPEC', "Build a gem file from its spec") { |spec|
        o.operation = :build
        o.argument  = spec
      }
  
      op.separator("")
      op.separator("  Miscellaneous:")
      op.on('--alien', "Report 'unmanaged' or rogue files in the gem repository") {
        o.operation = :alien
      }
      op.on('--verify GEM', "Verify gem file against its internal checksum") { |gem|
        o.operation = :verify
        o.argument  = gem
      }
  
      op.separator("")
      op.separator("Modifiers:")
  
      op.on(      '--config-file FILE', "Use this config file instead of default") {}
          # We ignore config files at this stage; they should have been dealt with already.
      op.on(      '--install-dir DIR',  "Specify RubyGems installation directory") {|o.directory|}
      op.on(      '--force',            "Force gem to intall, bypassing dependency checks") {|o.force|}
      op.on(      '--gen-rdoc',         "Generate RDoc documentation for the gem on install") {|o.gen_rdoc|}
      op.on(      '--run-tests',        "Run unit tests prior to installation") {|o.run_tests|}
      op.on(      '--http-proxy PROXY', "Use HTTP proxy (full http:// URL) for remote operations") { |o.http_proxy| }
      op.on(      '--version VERSION',  "Specify version of gem to perform operation on") {|o.gem_version|}
      op.on('-L', '--local',            "Restrict operations to the LOCAL domain") { o.domain = :local }
      op.on('-R', '--remote',           "Restrict operations to the REMOTE domain") { o.domain = :remote }
      op.on('-B', '--both',             "Allow LOCAL and REMOTE operations") { o.domain = :both }
  
      op.separator("")
      op.separator("Miscellaneous:")
  
      op.on('-h', '--help', "Display this message and exit") {
        _show_help(op, 0)
      }
      op.on('--rubygems-info', "Display RubyGems information and exit") {
        _show_rubygems_info()
      }
  
      op.separator("")
      message = <<-INFO

'gem' is the user interface to RubyGems, the Ruby package manager.

See http://rubygems.rubyforge.org for:
   * gem command-line reference
   * quick introduction to RubyGems
   * user and developer documentation

In the above information, "GEM" typically refers to the name of a gem;
all of the following are valid (perhaps in different circumstances):

      ruby-dbi
      ruby-dbi-0.20.1
      ruby-dbi-0.20.1.gem

See the online 'gem reference' for more information on environment
variables, configuration files, and more.
INFO
      message.each do |line|
        op.separator(line.chomp)
      end
    end  # OptionParser.new
  
    begin
      parser.parse!(args)
    rescue => err
      puts err.message
      exit!
    end
    options = o
    _show_help(parser, 1) if options.operation.nil?
  
#     require 'pp'
#     pp options
#     puts
#     exit
    options
  end  # _parse

  def _show_help(parser, status)
    puts parser
    exit(status)
  end

  def _show_rubygems_info
    puts "RubyGems:"
    puts " - VERSION:                #{Gem::RubyGemsVersion}"
    puts " - INSTALLATION DIRECTORY: #{Gem.dir}"
    puts " - GEM PATH:"
    puts Gem.path.map { |p| "     - #{p}" }
    puts " - REMOTE SOURCES:"
    puts Gem::RemoteInstaller.new.get_cache_sources.map { |s| "     - #{s}" }
    exit
  end

end  # class RubyGemsApp



#
# -_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
#


#
# This class performs the basic operations that the user can select on the command line.
#
class RubyGemsFacade

  # Signals that local installation will not proceed, not that it has been tried and
  # failed.  TODO: better name.
  class LocalInstallationError < StandardError; end

  # Signals that a remote operation cannot be conducted, probably due to not being
  # connected (or just not finding host).
  #
  # TODO: create a method that tests connection to the preferred gems server.  All code
  # dealing with remote operations will want this.  Failure in that method should raise
  # this error.
  class RemoteError < StandardError; end
  

  def initialize(options)
    @options = options
    @options.gem_version ||= "> 0.0.0"
  end


  #
  # Decide whether to perform a local or remote install.  Then generate RDocs if desired.
  #
  # This can only be local (argument is a path, even though it doesn't end in '.gem').
  #   gem --install /tmp/ruby-doom-0.0.7
  #
  # This can only be local (argument is not necessarily a path, but it ends in '.gem').
  #   gem --install ruby-doom-0.0.7.gem
  #
  # This could be local (gem file in current directory) or remote.  Installation is attempted in
  # that order.
  #   gem --install ruby-doom-0.0.7
  #   
  # This could be local (gem file in current directory with highest available version number) or
  # remote.  Installation is attempted in that order.
  #   gem --install ruby-doom
  #
  # Basically, our approach in this method is to attempt a local installation.  If that
  # fails, then we attempt a remote installation.  Of course, we respect --local and
  # --remote.
  #
  # Returns true or false to indicate success.  TODO: is this necessary?
  #
  def install(gem)
    if @options.local?
      begin
        _info "Attempting local installation of '#{gem}'"
        installed_gems = _install_local(gem)
      rescue LocalInstallationError => e
        _info " -> Local installation can't proceed: #{e.message}"
      rescue => e
        $stderr.puts "Error installing gem #{gem}: #{e.message}"
        return false # If a local installation actually fails, we don't try remote.
      end
    end

    if @options.remote?
      begin
        _info "Attempting remote installation of '#{gem}'"
        installed_gems = _install_remote(gem)
      rescue RemoteError => e
        _info " -> Remote installation can't proceed: #{e.message}"
      rescue => e
        $stderr.puts "Error installing gem #{gem}: #{e.message + e.backtrace.join("\n")}"
        return false
      end
    end

    if @options.gen_rdoc
      installed_gems.each do |gem|
        Gem::DocManager.new(gem).generate_rdoc
      end
      # TODO: catch exceptions and inform user that doc generation was not successful.
    end

    if @options.run_tests
      installed_gems.each do |gem|
        _run_tests(gem.name, gem.version)
      end
    end

    return true 
  end


  #
  # Uninstall the named gem.  
  # If no version is specified, the latest version will be uninstalled.
  # XXX: We should probably change this so that if no version is specified,
  #    all versions of the named gem are uninstalled.
  def uninstall(gem)
    _info "Attempting to uninstall gem '#{gem}'"
    Gem::Uninstaller.new(gem, @options.gem_version).uninstall
  end


  #
  # This lists local _and_ remote gems beginning with 'F' (case-insensitive optional argument).
  #   gem --list F
  #
  def list(str)
    _list_gems(/^#{str}/i)
  end


  #
  # List local and remote gems containing the given string.
  #
  def search(str)
    _list_gems(/#{str}/i)
  end


  # 
  # The output depends on whether the named package is installed locally.
  #
  # If it is, then the normal report happens, and the remote server is queried and a brief report
  # provided to say whether there are any updates.
  #
  # If it is not, then a full remote report is provided.
  #
  def info(gem)
    if @options.local?
      gem_specs = Gem::Cache.from_installed_gems.search(gem, @options.gem_version)
      if gem_specs.size > 0
        require 'yaml'
        gem_specs.each {|spec| puts spec.to_yaml; puts "\n"}
      else
        $stderr.puts "Unkown gem #{gem}"
      end
    end

    if @options.remote?
      _info "(Remote 'info' operation is not yet implemented.)"
      # NOTE: when we do implement remote info, make sure we don't duplicate huge swabs of
      # local data.  If it's the same, just say it's the same.
    end
  end


  #
  # Build a gem from the given gemspec.  This can only be done locally :)
  #
  def build(gemspec)
    _info "Attempting to build gem spec '#{gemspec}'"
    load gemspec
    Gem::Specification.list.each do |spec|
      Gem::Builder.new(spec).build
    end
  end


  #
  # Scour the repository for alien (unmanaged) files.
  #
  def alien
    _info "Performing the 'alien' operation"  # TODO: better (or no) message.
    Gem::Validator.new.alien
  end


  #
  # Verify the given gem.
  #
  def verify(gem)
    _info "Verifying gem: '#{gem}'"
    begin
      Gem::Validator.new.verify_gem_file(gem)
    rescue => e
      $stderr.puts "#{gem} is invalid"
    end
  end

  private

  #
  # Attempt a local installation.  Returns the list of installed gems.
  # Raises an error if installation not possible or if installation
  # fails.
  #
  def _install_local(path)
    unless File.exist?(path)
      if File.exist?(path + ".gem")
        path << ".gem"
      else
        # Raising this is intended to communicate that this gem cannot
        # be locally installed.
        raise LocalInstallationError, "Unknown gem file '#{path}'"
      end
    end
    installer = Gem::Installer.new(path)
    result = installer.install(@options.force, @options.directory)
    [result].flatten
  end

  #
  # Attempts a remote installation.  Returns list of installed gems.  Errors are passed
  # upstream, but there is no specific error to indicate that we are not connected to the
  # internet, unfortunately.
  #
  # TODO: make use of RemoteError, if possible. 
  #
  def _install_remote(name)
    installer = _get_remote_installer
    begin
      installed_gems = installer.install(name, @options.gem_version, @options.force, @options.directory)
    rescue Exception => e
        $stderr.puts e.to_s
        exit 1
    end
    installed_gems
  end

  def _run_tests(name, version)
    gem_specs = Gem::Cache.from_installed_gems.search(name, version.version)
    unless gem_specs[0].test_suite_file
      _info "There are no unit tests to run for #{name}-#{version}"
      return
    end
    require_gem name, "= #{version.version}"
    require gem_specs[0].test_suite_file
    suite = Test::Unit::TestSuite.new("#{name}-#{version}")
    ObjectSpace.each_object(Class) do |klass|
      suite << klass.suite if (Test::Unit::TestCase > klass)
    end
    require 'test/unit/ui/console/testrunner'
    result = Test::Unit::UI::Console::TestRunner.run(suite, Test::Unit::UI::SILENT)
    unless(result.passed?)
      print result.to_s + "...keep Gem? [Y/n] "
      answer = gets
      if(answer !~ /^y/i) then
        Gem::Uninstaller.new(name, version.version).uninstall
      end
    end
  end

  def _get_remote_installer
    Gem::RemoteInstaller.new(@options.http_proxy)
  end

  # List all gems, local and/or remote, that match the given pattern.  This provides the
  # common factor between 'list' and 'search'.
  #
  # TODO: ignore remote gems that are available locally?  Or just list them?  Or what? 
  def _list_gems(pattern)
    if @options.local?
      puts
      puts "*** LOCAL GEMS ***"
      gemlist = []
      Gem::Cache.from_installed_gems.each do |name, spec|
        gemlist << [name, spec]
      end  # FIXME: Gem::Cache.search already does this.
      _display_gems(gemlist.select { |name, spec| name =~ pattern })
    end

    if @options.remote?
      puts
      puts "*** REMOTE GEMS ***"
      installer = _get_remote_installer
      begin
        _display_gems(installer.search(pattern))
      rescue Gem::RemoteSourceException => e
        $stderr.puts e.to_s
        exit 1
      end
    end
  end

  # +gems+ is actually an Array: [[name, gemspec], [name, gemspec], ...]
  def _display_gems(gems)
    already_seen = []
    gems.sort {|a,b| 
      a[0].downcase <=> b[0].downcase
    }.each do |gem|
      unless(already_seen.include?(gem[0])) 
        puts
        _display_gem(gem)
        already_seen << gem[0]
      end
    end
  end

  # +gem+ is actually an Array: [name, gemspec]
  def _display_gem(gem)
    name, spec = gem
    puts name
    puts spec.summary.wrap(68).indent(4)
  end

end  # class RubyGemsFacade


#
# -_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
#


#
# These implementations are not idiot-proof or intended for general use.  They are to support
# the pretty-printing of lists of gems.
#
class String # :nodoc:
  # Wrap string to +n+ characters, inserting newlines and ensuring words are not broken.
  # Stolen from 'ri'. 
  def wrap(n)
    result = []
    pattern = Regexp.new("^(.{0,#{n}})[ \n]")
    work = self.dup
    while work.length > n
      if work =~ pattern
        result << $1
        work.slice!(0, $&.length)
      else
        result << work.slice!(0, n)
      end
    end
    result << work if work.length.nonzero?
    result.join("\n")
  end

  # Indent string by +n+ spaces.
  def indent(n)
    gsub(/^/, " " * n)
  end
end

#
# -_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
#

# (main)

RubyGemsApp.new.run(ARGV)
