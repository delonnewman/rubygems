#!/usr/bin/env ruby

##
# gem_server and gem_server.cgi are equivalent programs that allow  
# users to serve gems for consumption by `gem --remote-install`.
# 
# gem_server starts an HTTP server on the given port, and serves the folowing:
# * "/" - Browsing of gem spec files for installed gems
# * "/yaml" - Full yaml dump of metadata for installed gems
# * "/gems" - Direct access to download the installable gems
#
# Usage: gem_server [-p portnum] [-d gem_path]
# port_num:: The TCP port the HTTP server will bind to
# gem_path:: Root gem directory containing both "cache" and "specifications"
#   subdirectories.
if __FILE__ == $0
  require 'webrick'
  require 'yaml'
  require 'rubygems'
  require 'optparse'
  options = {}
  ARGV.options do |opts|
    opts.on_tail("--help", 
      "show this message") {puts opts; exit}
    opts.on('-pPORT','--port=PORT', 
      "Specify the port to listen on") { |options[:port]| }
    opts.on('-dGEMDIR','--dir=GEMDIR', 
      "Specify the directory from which to serve Gems") { |options[:gemdir]| }
    opts.parse!
  end

  s = WEBrick::HTTPServer.new(:Port         => options[:port] || 8808)
  s.mount_proc("/yaml") {|req, res|
    res['content-type'] = 'text/plain'
    res.body << Gem::Cache.from_installed_gems(File.join(options[:gemdir] || Gem.dir, "specifications")).to_yaml
  }
  {"/" => "/specifications/", "/gems" => "/cache/"}.each do |mount_point, mount_dir|
    s.mount(mount_point, WEBrick::HTTPServlet::FileHandler, File.join(options[:gemdir] || Gem.dir, mount_dir), true)
  end
  trap("INT"){ s.shutdown }
  s.start
end
